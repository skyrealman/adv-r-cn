# 表达式 {#expressions}

```{r, include = FALSE}
source("common.R")
```

## 概述

要计算语言，我们首先需要了解它的结构，这需要我们掌握一些新词汇、学习一些新工具具备一些思考 R 代码的新方法。第一个新的理解就是要明白操作与其结果之间的区别。
使用以下代码，将变量 `x`乘以10，并把结果保存到新变量 `y`中，这是不起作用的，因为我们还没有定义一个名为 `x`的变量：

```{r, error = TRUE}
y <- x * 10
```

如果我们能够在不执行代码的情况下捕获代码的意图，那就太好了。换句话说，怎样才能将我们对行为的描述与行为本身区分开来？

一种方法是使用 `rlang::expr()`:

```{r}
z <- rlang::expr(y <- x * 10)
z
```

`expr()`返回一个表达式，表达式是一种捕获代码结构但不计算（即运行代码）的对象。如果有表达式，可以使用 `base::eval()`方法对其进行求值。

```{r}
x <- 4
eval(z)
y
```

本章的重点是介绍表达式的数据结构，掌握这些知识将允许您检查和修改捕获的代码，并使用代码生成代码。我们将在第\@ref(quasi)章重新研究 `expr()`，在第
\@ref(evaluation)章中研究 `eval()`。

### 题纲 {-}

- 第\@ref(ast)节介绍了抽象语法树(AST)的思想，并揭示了所有R代码背后的树状结构。

- 第\@ref(expression-details)节介绍了支持AST的数据结构：常量、符号和调用，它们统称表达式。

- 第\@ref(parsing-and-grammar)节介绍了解析，即将代码中的线性字符序列转换为AST的行为，同时使用该思想探索一下R语言的语法细节。

- 第\@ref(ast-funs)节向您展示了如何使用递归函数在语言上进行计算，编写计算上述表达式的函数。

- 第\@ref(expression-special)节讨论三个更加专业的数据结构：成对列表、缺失参数和表达式向量。

### 先决条件 {-}

请确保您已经学习了第\@ref(bigpicture)章关于元编程的相关知识，您还需要使用[rlang](https://rlang.r-lib.org)包来捕获和计算表达式，
并且使用[lobstr](https://lobstr.r-lib.org)包来可视化结果。

```{r setup}
library(rlang)
library(lobstr)
```

## 抽象语法树 {#ast}

表达式通常也被称为**抽象语法树**，这是因为代码的结构是分层的，自然可以表示为树的形式。了解这种树状结构对于监测和修改代码是十分重要的（比如在元编程领域）。

### 绘制

我们将介绍关于绘制AST的一些约定, 首先从显示树的主要组件的开始： `f(x, "y", 1)`。我将用两种方式[^more-complex]绘制这棵树：

- 手绘。（比如使用OmniGraffle等软件）：

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/expressions/simple.png")
```

- 使用 `lobstr::ast()`函数：

```{r}
lobstr::ast(f(x, "y", 1))
```

[^more-complex]: 对于更复杂的代码，您还可以使用RStudio的树查看器，它不遵守完全相同的图形约定，但允许您以交互方式浏览大型AST。使用 `View(expr（f（x，“y”，1）)`试试看。


两种方式尽可能共享约定：

- 树的叶节点可以是符号或者常量，符号用粉红色圆角矩形表示，常量用黑色举行表示，字符串与符号不容易区分，因此字符串总是用引号包围。

- 树的分支是调用对象，表示函数调用，并绘制为橙色的矩形。第一个子节点 `f`表示函数调用，后面的节点（ `x`, `"y"`, `1`)为函数参数。

调用 `ast()`函数时将显示颜色，但由于复杂的技术问题，颜色不会出现在本书中。

上面的示例只包含一个函数调用，这使得树非常浅。大多数表达式将包含相当多的调用，从而创建具有多个级别的树。例如，函数 `f(g(1, 2), h(3, 4, i()))` 的语法树为：

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/expressions/complicated.png")
```

```{r}
lobstr::ast(f(g(1, 2), h(3, 4, i())))
```

您可以从左到右（忽略垂直位置）阅读手绘图，从上到下（忽略水平位置）阅读lobstr生成图。树中的深度由函数的嵌套决定，这也决定了计算顺序，因为计算通常是从深到浅进行，
但是由于延迟计算\@ref(lazy-evaluation)的存在，通常情况也无法完全保证是这样的计算次序。还要注意 `i()`函数的存在，这是一个没有参数的函数调用，它的分支只有一个叶节点。

### 非代码部分

您可能想知道这些抽象语法树是由什么组成的。它们是抽象的，因为它们只捕获代码的重要结构细节，而包括空格或注释：

```{r}
ast(
    f(x, y)  # important !
)
```

只有一个地方的空格是可以体现在语法树里的：

```{r}
lobstr::ast(y <- x)

lobstr::ast(y < -x)
```

### 中缀调用

R中所有的调用都可以用树的形式表示，是因为任何调用都可以表达为前置形式（\@ref(prefix-transform)）。让我们重新审视 `y <- x + 10`：正在被调用的函数到底是什么？
它不像函数`f(x, 1)`这么容易被识别，因为这个表达式里包含了两个中缀调用： ` <- `和 `*`。这意味着下面两行代码是等价的：

```{r}
y <- x * 10
`<-`(y, `*`(x, 10))
```

它们拥有同样的AST[^ast-infix]:

[^ast-infix]: 上面的前置函数名是非法的，所以我采用``` `` ```符号把它包围，具体原因详见\@ref(non-syntactic)节

```{r, echo = FALSE, out.width = NULL}
knitr::include_graphics("diagrams/expressions/prefix.png")
```

```{r}
lobstr::ast(y <- x * 10)
```

AST之间实际没有区别，如果生成带有前缀调用的表达式，R仍将以中缀形式打印它。

```{r}
expr(`<-`(y, `*`(x, 10)))
```

中缀运算符的应用顺序由一组称为运算符优先级的规则控制，我们将在\@ref(operator-precedence)节中使用 `lobstr::ast()`来深入研究。

### 习题

1. 重建以下语法树表达的代码：

```{r, echo = FALSE}
ast(f(g(h())))
ast(1 + 2 + 3)
ast((x + y) * z)
```

1. 手绘出下列代码的语法树，并用 `lobstr::ast()`检查：

```{r, eval = FALSE}
f(g(h(i(1, 2, 3))))
f(1, g(2, h(3, i())))
f(g(1, 2), h(3, i(4, 5)))
```

1. 下面的AST发生了什么？（提示：请仔细阅读文档`?"^"`）

```{r}
lobstr::ast(`x` + `y`)

lobstr::ast(x ** y)

lobstr::ast(1 -> x)
```

1. 下面的AST有何特别之处？（提示：请重新阅读\@ref(function-components)节）

```{r}
lobstr::ast(function(x = 1, y = 2) {})
```

1. 带有多个else if条件的if语句，其调用树是什么样子？为什么？

## 表达式 {#expression-details}

### 常量

### 符号

### 调用

### 总结

### 习题

## 解析与语法 {#parsing-and-grammar}

### 运算符优先级 {#operator-precedence}

### 结合性

### 解析与反解析

### 习题

## 使用递归函数遍历虚拟语法树 {#ast-funs}

### 查找`F`与`T`

### 查找由赋值语句创建的所有变量

### 习题

## 特殊的数据结构 {#expression-special}

### 成对列表 {#pairlists}

### 缺失参数

### 表达式向量
