# 表达式 {#expressions}

```{r, include = FALSE}
source("common.R")
```

## 概述

要计算语言，我们首先需要了解它的结构，这需要我们掌握一些新词汇、学习一些新工具具备一些思考 R 代码的新方法。第一个新的理解就是要明白操作与其结果之间的区别。
使用以下代码，将变量 `x`乘以10，并把结果保存到新变量 `y`中，这是不起作用的，因为我们还没有定义一个名为 `x`的变量：

```{r, error = TRUE}
y <- x * 10
```

如果我们能够在不执行代码的情况下捕获代码的意图，那就太好了。换句话说，怎样才能将我们对行为的描述与行为本身区分开来？

一种方法是使用 `rlang::expr()`:

```{r}
z <- rlang::expr(y <- x * 10)
z
```

`expr()`返回一个表达式，表达式是一种捕获代码结构但不计算（即运行代码）的对象。如果有表达式，可以使用 `base::eval()`方法对其进行求值。

```{r}
x <- 4
eval(z)
y
```

本章的重点是介绍表达式的数据结构，掌握这些知识将允许您检查和修改捕获的代码，并使用代码生成代码。我们将在第\@ref(quasiquotation)章重新研究 `expr()`，在第
\@ref(evaluation)章中研究 `eval()`。

### 题纲 {-}

- 第\@ref(ast)节介绍了抽象语法树(AST)的思想，并揭示了所有R代码背后的树状结构。

- 第\@ref(expression-details)节介绍了支持AST的数据结构：常量、符号和调用，它们统称表达式。

- 第\@ref(parsing-and-grammar)节介绍了解析，即将代码中的线性字符序列转换为AST的行为，同时使用该思想探索一下R语言的语法细节。

- 第\@ref(ast-funs)节向您展示了如何使用递归函数在语言上进行计算，编写计算上述表达式的函数。

- 第\@ref(expression-special)节讨论三个更加专业的数据结构：成对列表、缺失参数和表达式向量。

### 先决条件 {-}

请确保您已经学习了第\@ref(bigpicture)章关于元编程的相关知识，您还需要使用[rlang](https://rlang.r-lib.org)包来捕获和计算表达式，
并且使用[lobstr](https://lobstr.r-lib.org)包来可视化结果。

```{r setup}
library(rlang)
library(lobstr)
```

## 虚拟语法树 {#ast}



### 绘制

### 非代码组件

### 前缀调用

### 习题

## 表达式 {#expression-details}

### 常量

### 符号

### 调用

### 总结

### 习题

## 解析与语法 {#parsing-and-grammar}

### 运算符优先级

### 结合性

### 解析与反解析

### 习题

## 使用递归函数遍历虚拟语法树 {#ast-funs}

### 查找`F`与`T`

### 查找由赋值语句创建的所有变量

### 习题

## 特殊的数据结构 {#expression-special}

### 成对列表 {#pairlists}

### 缺失参数

### 表达式向量
