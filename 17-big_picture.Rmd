# 全景 {#bigpicture}
```{r, include = FALSE}
source("common.R")
```

## 概述

元编程是本书中最难的章节，因为它汇集了很多以前毫不相关的话题，迫使您去解决那些以前可能从未想过的问题。您还需要学习很多新的词汇，一开始似乎每个新术语都是由几个您从未听
说的术语定义的。即使您是一名有着其他编程语言经验的程序员，您现有的技能也不太可能有很大帮助，因为很少有现代流行语言可以展示R提供的元编程水平。所以，如果您一开始感到沮丧
或困惑，不要感到惊讶，这是每个人都会经历的过程。

但我认为现在学习元编程比以往任何时候都容易，在过去几年中，元编程的理论与实践已经成熟，提供了强大的基础以及可以让您解决常见问题的工具。本章您将了解所有主要能力以及它们如何
组合在一起。

### 题纲 {-}

本章中的每个小节将介绍一种全新且重要的理念：

- \@ref(code-is-data)节介绍代码即数据的相关知识，它将教会您如何通过捕获代码来创建和修改表达式。

- \@ref(code-is-a-tree)节介绍代码的树状结构，称为抽象语法树。

- \@ref(code-can-generate-code)节介绍如何以代码的方式创建新的表达式。

- \@ref(evaluation-run-code)节演示如何通过在环境中计算表达式来执行它们。

- \@ref(customing-evaluation-with-function)节介绍如何通过在新环境中提供自定义函数来定义计算。

- \@ref(customing-evaluation-with-data)节将自定义扩展到数据掩码，这模糊了环境和数据框之间的界限。

- \@ref(quosure)节介绍了一种名为quosure的新数据结构，它使得元编程更加简单。

### 先决条件 {-}

本章将介绍使用`rlang`包来掌握元编程全景的方式，后面的章节也会介绍使用R基础包做类似事情的方法，我们还将使用`lobstr`包来探索代码树的结构。

```{r}
library(rlang)
library(lobstr)
```

请确保在学习本章前，您对R语言的环境（第\@ref(environment-basic)节）与数据框（第\@ref(dataframe-and-tibble)）这两个概念已经十分了解。

## 代码即数据 {#code-is-data}

第一个重要的观点是代码即数据，您可以捕获代码并对其进行计算，就像处理任何其他类型的数据一样。第一种可以捕获代码的方式是使用`rlang::expr()`函数，
您可以认为`expr()`函数精准的返回了您的输入：

```{r}
expr(mean(x, na.rm = TRUE))

expr(10 + 100 + 1000)
```

大多数情况下，捕获的代码被称为**表达式**，表达式并不是一类独立的对象，而是四种类型的集合（调用，变量符号，常量，或键值对），具体内容您将在\@ref(expressions)章中学习。

`expr()`函数用于捕获您输入的代码，您同样还需要其它工具来捕获传入函数的代码，这种情况下`expr()`函数就无法使用了：

```{r}
capture_it <- function(x) {
    expr(x)
}

capture_it(a + b + c)
```

这里您需要使用一个专门设计的函数来捕获函数参数中的用户输入：`enexpr()`，这里的"en"代表单词“enrich"，`enexpr()`接受一个延迟计算参数，并将其转换为表达式。

```{r}
capture_it <- function(x) {
    enexpr(x)
}

capture_it(a + b + c)
```

由于`capture_it()`函数使用了`enexpr()`，它将可以自动引用第一个输入参数，这一点您将在\@ref(vocabulary)节学习。

一旦您捕获了表达式，您可以检查或者修改它，复杂表达式的行为很像列表，这就意味着您可以使用`[[`或`$`修改它们。

```{r}
f <- expr(f(x = 1, y = 2))

# Add a new argument
f$z <- 3
f

# Or remove an argument:
f[[2]] <- NULL
f
```

调用过程的第一参数是被调用的函数，也就是说函数的参数将出现在第二个参数的位置上，这一点您将在\@ref(expression-details)节中学习到完整的知识。

## 代码是语法树 {#code-is-a-tree}

要对表达式有更复杂的操作，您需要完全理解它的结构。 在一个运行程序的背后，几乎每种编程语言都将代码表示为一棵树，这个树通常被称为是**虚拟代码树**，简称AST。
R语言之所以与众不同，是因为它允许用户检查和操作这棵代码树。

`lobstr::ast()`是一个方便我们理解代码树的工具，函数会展示出代码背后的组织结构。函数调用形成树的分支，并以矩形进行展示。树的叶节点代表变量符号（比如`a`）和常量（比如`b`）。

```{r}
lobstr::ast(f(a, "b"))
```

嵌套函数调用会创建一个拥有深度分支的树：

```{r}
lobstr::ast(f1(f2(a, b), f3(1, f4(2))))
```

因为R语言中所有的函数都可以被表示成前缀形式（详见\@ref(prefix-form)），因此每个R的表达式可以按如下方式进行展示：

```{r}
lobstr::ast(1 + 2 * 3)
```

以这种方式显示AST是一种探索R语法的有用工具，在\@ref(parsing-and-grammar)节中我们会详细介绍。

## 代码可以生成代码 {#code-can-generate-code}

除了从人工输入的代码中看到代码结构树以外，还可以使用代码创建新树。新建树可以使用两个主要的工具：`call2()`和取消引用。

`rlang::call2()`函数使用其它组件构造函数调用：要调用的函数和要使用的参数。

```{r}
call2("f", 1, 2, 3)

call2("+", 1, call2("*", 2, 3))
```

`call2()`函数对于编程比较方便，但对于交互式使用有些笨拙，另一种技术是通过将更简单的代码树与模板相结合来构建复杂的代码树。`expr()`和`enexpr()`函数的功能内置在
`!!`取消引用符号中，以支持上述的复杂代码树的构建。

具体细节我们在\@ref(unquoting)节学习，现在需要了解的是 `!!x`将 `x` 中存储的代码树插入到表达式中，这使得我们可以通过简单的代码片断来创建复杂代码树。

```{r}
xx <- expr(x + x)
yy <- expr(y + y)

expr(!!xx / !!yy)
```

请注意，输出结果保持运算符的优先级，所以我们得到的是 `(x + x)/(y + y)`，而并不是 `x + x/y + y`。这十分重要，特别是您可能会一直想，这是不是仅仅将字符串贴到一起而已。

当您将取消引用封装进函数以后，它变得更加有用。首先使用 `enexpr()`函数捕获用户输入的表达式，之后 `expr()`函数或 `!!`使用模板创建一个新的表达式。下面的示例显示了如何生成
计算变异系数的表达式：

```{r}
cv <- function(var) {
    var <- enexpr(var)
    expr(sd(!!var) / mean(!!var))
}

cv(x)
cv(x + y)
```

(在这里并不是很有用，但创建这种代码块在解决更复杂问题时非常有用)

更为重要的是，即使给定了奇怪的变量名，这种代码块也会起作用：

```{r}
cv(`)`)
```

可以处理奇怪变量名[^non-syntactic]的能力也是另一个我们要避免在生成代码时使用 `paste()`函数的原因，您可能认为这是一个深奥的问题，但对比在 Web 应用程序中生成 SQL 的代码导致 SQL 
注入攻击，而花费总成本高达数十亿美元去解决时，您就不必担心类似于这样的问题。 

[^non-syntactic]: 更严格地说，这些名称称为非法名称，我们在 第\@ref(non-syntactic)节时已经进行了讨论。

## 计算运行代码 {#evaluation-run-code}

## 使用函数定制计算 {#customing-evaluation-with-function}

## 使用数据定制计算 {#customing-evaluation-with-data}

## Quosure {#quosure}
