[["index.html", "R语言高级程序设计 前言", " R语言高级程序设计 宋震 2021-10-25 前言 欢迎阅读《R语言高级程序设计》，本书为《Advanced R》（第二版）(Wickham 2021)的中文译版（作者为R语言大神Hadley Wickham），在第二版中作者主要强调了以下三方面的内容： 提高对重要概念的覆盖程度，其中很多的概念也是作者在第一版出版后才深入理解的 在第一版中作者认为减少对每项内容的介绍时间是有益处的，但事实证明这种做法并不实用 一般而言，更流畅的文字、更清晰的代码和更丰富的图表使书籍更加容易理解 假如您比较熟悉本书的第一版，可以通过阅读本章节聚焦那些新增的内容。如果您曾经阅读过印刷的版本，您将看到一个巨大的变化： 第二版是彩色印刷的。这大大改进了代码块语法的突显程度，同时使得图表更加清晰。因此，作者在第二版图书中加入了100多个新的图表，来提升章节知识点的易读性。 这个版本的另一个重大变化是使用了很多新版的包，特别是rlang包，它为一些低级别的数据结构和操作提供了干净的接口。第一版几乎完全使用了base R包的函数，这带来了一些学习上的困难，因为许多函数经过多年独立发展，很难看到隐藏在函数名和参数背后的设计思想。不过作者依然在侧边栏、脚注等地方显示了base R包中相关函数的用法，但如果您希望看到最纯粹的base R表达式，建议阅读本书的第一版Advanced R。 R语言相关的基础知识自本书第一版以来没有发生过变化，但事实上存在很大的不同。因此，第二版的基础知识版块虽然在结构上保持不变，但个别章节有了相当大的改进： 第 2 章“对象名与对象值”是新增加的章节，目的是帮助您快速理解对象与对象引用之间的区别。这有助于您更准确的判断R语言是何时开始复制数据，并为理解函数式编程奠定重要基础。 第 3 章“向量”（上个版本称为数据结构）被重写，它更聚焦于整型、因子型和数据框等向量类型。这一章包含了关于S3向量（如时期类型和日期时间类型）更多详细信息，讨论了tibble包(Müller and Wickham 2018)提供的全新数据框的变化，总体上反应了作者对向量数据类型的更好理解。 第 4 章“子集”强调了[与[[的区别：[用于提取多个值而[[用于提取单个值（以前它们被表示为“简化”或者“保留”）。第 4.2 节通过绘制一列“火车”向您形象的解释了[[如何与列表一起工作，同时引入了全新的函数，为索引的越界提供一致化的表达。 第 5 章“控制流”是一个全新的章节：上个版本居然将if、for等如此重要的工具忘记了！ 第 6 章“函数”改进了章节排序，介绍了管道（%&gt;%）这个第三方的函数（第6.2节），并且覆盖了更多的函数类型（第6.3节）。 第 7 章“环境”重新组织了特殊环境章节（第7.4节），同时就堆栈调用开展了更多讨论（第7.5节）。 第 8 章“条件”包含了上一版在“异常和调试”章节中的相关内容，以及关于R语言条件系统如何工作的许多新内容。同时本章还向您展示了如何创建自定义条件类（第8.1节）。 每一部分“基础知识”之后的章节围绕着R语言三种最重要的编程范式重新组织，分别是：函数式编程、面向对象编程和元编程。 函数式编程部分被更为清晰的划分为三个章节：“泛型函数（第9章）”，“函数工厂（第10章）”，“函数运算符（第11章）”。这部分内容作者减少了纯理论讲述，而聚焦这些范式在数据科学中的实际应用。 这些章节现在使用了purrr(Henry and Wickham 2018)包提供的部分函数，使得读者可以更加聚焦在基本思想而不是附带的细节，这也使得函数运算符这一章更为简化，因为当您使用基础泛型函数时，大部分的工作是在处理不定参数（...）的问题。 面向对象编程部分由全新的五个章节组成，包括基本类型（第12章），S3对象系统（第13章），S4对象系统（第15章），R6对象系统（第14章），并且对比了不同对象系统的优劣（第16章）。 这些章节的重点是不同对象系统如何工作，而不是如何有效的使用它们。这是十分必要的，因为很多技术细节没有其它地方可以书写，并且要有效使用面向对象的编程范式需要一整本书的解读。 元编程（过去被称为“语言上的计算”）是一组可以通过代码生成代码的工具。对比上一版书籍，这次的版本已经大幅扩展内容，并且聚焦在代码的“整洁性评估”方面，这是一套使元编程安全性更佳、原则性更强以及易用性更广的理论。第17章“全局”粗略的介绍了如何将所有的代码部件进行拼装；第18章“表达式”介绍了底层的数据结构；第19章“准引用”介绍了引用与反引用的相关知识；第20章“评估”解释了在特殊环境下如何进行代码评估；第21章“代码转换”综合上述章节的知识介绍了如何在各种编程语言之间进行转换。 本书的最后一部分汇聚了关于编程技术的相关知识，包括：评测、度量、性能改进以及Rcpp。内容与第一版十分接近，只是在结构组织方面有所调整。作者在这些章节中针对新的软件包使用进行了更新（microbenchmark -&gt; bench，lineprof -&gt; profvis），但大部分文本都是相同的。 虽然第二版的书籍在第一版的基础上扩大了知识的覆盖面，但依然删除了下列五章的内容： 词汇表章节被删除，因为它看起来有点奇怪，而且有很多比在书的章节中呈现词汇更有效的办法。 样式章节被在线化的样式指南所替代，http://style.tidyverse.org。样式指南可以与很多全新的样式包配套使用。 C语言章节被移动到https://github.com/hadley/r-internals，随着时间的推移，这将为编写与R的数据结构一起工作的C代码提供指导。 内存章节被删除，其中部分的内容被合并至第2章，删除了那些看起来很技术化但没有那么重要的内容。 R语言的性能章节被删除，这部分内容确实有一些可操作性，但随着R语言的不断发展已经过时。 参考文献 "],["author.html", "译者简介 关于本书 关于环境 致谢", " 译者简介 宋震，一名快乐的小销售，喜欢折腾R，tidyverse，tidymodels……有时觉得公司的程序员不给力…… 关于本书 本书的产生纯属译者2021年国庆假期在家无聊，尝试研究一下R语言相对底层的内容。译者写过不少基于tidyverse的数据分析脚本，对R的底层知识产生了浓厚的兴趣，认真学习一下大神的书籍，以便可以出去吹更大的牛逼…… 关于环境 译者用了两个 R 包编译这本书，分别是 knitr (Xie 2015) 、bookdown (Xie 2021)。以下是译者的 R 进程信息： sessionInfo() ## R version 4.0.2 (2020-06-22) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 16.04.6 LTS ## ## Matrix products: default ## BLAS: /usr/lib/openblas-base/libblas.so.3 ## LAPACK: /usr/lib/libopenblasp-r0.2.18.so ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.24 digest_0.6.28 R6_2.5.1 jsonlite_1.7.2 ## [5] magrittr_2.0.1 evaluate_0.14 stringi_1.7.5 rlang_0.4.12 ## [9] jquerylib_0.1.4 bslib_0.3.1 rmarkdown_2.11 tools_4.0.2 ## [13] stringr_1.4.0 xfun_0.27 yaml_2.2.1 fastmap_1.1.0 ## [17] compiler_4.0.2 htmltools_0.5.2 knitr_1.36 sass_0.4.0 致谢 非常感谢2021年国庆的大雨，不然我应该还在某条高速上按喇叭呢…… 宋震 于北京 2021年10月5日 参考文献 "],["intro.html", "第 1 章 全书概览 1.1 为什么选择R语言 1.2 本书的读者范围 1.3 您将从本书中学到什么 1.4 您无法从本书中学到的内容 1.5 基础技能 1.6 推荐阅读 1.7 获取帮助 1.8 致谢 1.9 约定 1.10 使用的R包", " 第 1 章 全书概览 我已经在R领域编程超过15年了，在过去的5年里一直全职从事这项工作，这给了我足够的时间来研究这个语言是如何工作的。这本书是我试图将学到的知识传授给大家，这样您就可以快速理解R语言的细节。阅读此书可以帮助您避免我曾经走过的弯路，并教会您使用R语言的工具、技巧和习惯，帮助您解决各类问题。在这个过程中，我希望可以告诉大家，尽管R语言有时存在一些问题，但它的核心是一种为数据科学量身定做的优雅语言。 1.1 为什么选择R语言 如果您是一名R语言初学者，您可能需要了解为什么学习这样一门奇怪的语言是值得的，对我而言，R语言最棒的地方体现在： R是免费，开源，跨平台的语言。如果您使用R语言开展数据分析，任何人都可以很便捷的使用您的代码。 R拥有多样化并且广受欢迎的社区，既包括了在线社区（如rstats twitter社区），也包括了线下面对面社区（如许多R语言用户见面会）。这其中有两个令人振奋的社区组织，一个是R语言每周通讯，它可以让您方便的了解R语言的相关信息。另一个是R-Ladies，它是一个面向女性用户及少数性别用户的社区。 R拥有大量的统计建模、机器学习、可视化分析以及数据处理方面的工具包，无论您需要绘制图形还是建立模型，很有可能前人已经帮您完成了相关工作，您可以从中学习到很多知识。 R拥有用于展示成果的强大工具。RMarkdown可以轻松的将结果转换为HTML文件、PDF文件、Word文档、PowerPoint演示文稿、仪表盘等。Shiny可以帮助您在无需了解任何HTML或Javascript知识情况下创建漂亮的交互式应用程序。 R提供了RStudio集成开发环境，可以根据数据科学、交互式数据分析和统计编程的需要进行定制。 R拥有大量尖端工具，统计学和机器学习领域的研究人员通常会在他们的论文中配套一个R包，这意味着您可以立即获得最新的理论研究与技术实现。 R是数据分析领域的深层支撑语言，拥有缺失值、数据框、矢量化等诸多功能。 R对于函数式编程范式的支撑非常强大，函数式编程的思想十分契合数据科学，R的核心就是函数式，它提供了函数式编程所需要的许多原生能力。 RStudio是一家通过向R用户销售专业产品来盈利的公司，它将大部分资金投入到开源社区（RStudio中超过50%的软件工程师从事开源项目）。我为RStudio工作，因为我从根本上相信它的使命。 强大的元编程工具。R的元编程功能使您能够神奇地编写简洁明了的函数，并为设计特定领域的语言（如ggplot2、dplyr、data.table等）提供了一个极好的环境。 R可以轻松协同C、Fortran和C++这样的高性能编程语言。 当然，R语言并不完美，R所面临的最大挑战（也许是机遇）是R的主要用户并非程序员，这意味着： 您通常所看到的R代码都是为了解决一个紧迫的问题而匆忙编写的，因此代码并不是很优雅，且不易理解，而大多数用户不会去开展这些代码的优化工作。 相较于其他编程语言，R社区更关注结果而并不是过程，软件工程化是的相关优秀经验并没有在R语言开发中的完整应用。例如，大部分的R开发者没有使用源代码控制或或自动化测试。 元编程是一把双刃剑，很多R语言的函数使用一些代码技巧来减少键入量，这样的代价是代码变得难以理解或者出产生无法预料的错误。 前后不一致是R包中普遍存在的问题，每次使用R语言的时候，您都可以感受到超过25年的演进，这使得学习R非常困难，有太多的特殊情况需要记住。 R并不是一种速度很快的语言，写得不好的R代码可能会非常慢。R也是一个内存使用的大户。 我个人认为，这些挑战为经验丰富的程序员创造了一个巨大的机会，对R语言和R社区会产生积极深远的影响。R用户确实希望产出高质量的代码，特别是用于可复制的研究，但他们还没有掌握这样的技能。我希望这本书不仅能帮助更多的R语言的用户成为R程序员，还能鼓励其他语言的程序员为R做出贡献。 1.2 本书的读者范围 本书面向两类读者： 中级R语言程序员。他们希望深入研究R，了解这门语言的工作原理，学习新方法解决各类问题。 正在学习R的其他语言程序员。他们想了解为什么R语言会这样工作。 如果想要充分理解本书的内容，您需要用R或者其它语言编写大量的代码。您应该熟悉数据分析的基础知识（即数据导入、数据操作和数据可视化），编写过很多相关的函数，并熟悉CRAN软件包的的安装和使用。 我曾经在将这本书定义为参考书（主要用于查找）还是线性可读书籍之间纠结过。 这涉及一些权衡，因为很难在将相关材料保持在一起的同时还对材料进行线性化，而且如果您已经熟悉特定的技术词汇，那么某些概念更容易解释。我尝试使用脚注和交叉引用来确保即使您只是阅读了这章节，您仍然可以理解相关内容。 1.3 您将从本书中学到什么 这本书提供了我认为高级 R 程序员应该具备的知识：对基础知识的深刻理解加上广泛的词汇，这意味着您可以在需要时了解更多关于某个主题的知识。 阅读本书之后，您将： 熟悉 R 的基础。您将了解复杂的数据类型以及对它们执行操作的最佳方法。您将对函数的工作方式有深入的了解，您将知道什么是环境，以及如何使用条件系统。 了解函数式编程的含义，以及为什么它是数据科学的有用工具。您将能够快速学习如何使用现有工具，并在需要时拥有创建自己所需工具的能力。 了解 R 丰富多样的面向对象系统。您将最熟悉 S3，但您也会了解 S4 和 R6 以及在需要时从哪里可以查找到更多有关的信息。 感受元编程范式的优劣性。您将能够创建使用tidy风格的函数，减少代码的输入量，同时创建优雅的代码来实现重要的功能。您还将了解元编程的相关劣势以及如何避免。 拥有R语言性能方面的良好直觉。您将了解到如何使用R的分析能力来查明性能瓶颈，并且您将了解足够的 C++ 知识，以便您可将慢速 R 函数转换为快速 C++ 函数。 1.4 您无法从本书中学到的内容 这本书是关于R语言程序设计的，不是R语言数据分析。如果您需要提升自身在数据科学方面的技能，我建议您去学习tidyverse，这是我与我的同事们开发的一组工具包。在本书中您将学习开发tidyverse包的相关技能；如果您想学习如何使用它们，我推荐R for Data Science。 如果您希望他人使用您的代码，那么需要制作一个R包。这允许您可以将代码与文档、单元测试等捆绑在一起，并通过CRAN轻松分发。在我看来，开发一个包最简单的方法是使用devtools, roxygen2, testthat和 usethis. 你可以通过学习R packages这本书来了解上述工具包如何使用。 1.5 基础技能 有两种基础技能对提高R语言程序员的能力很有帮助：阅读代码与科学思维 阅读源代码很重要，因为它可以帮助您编写更好的代码。培养这项技能的一个好方法是查看您最常使用的函数和包的源代码。您可以在自己的代码中使用这些值得效仿的东西，您会对什么是好的 R 代码产生一种品味。您也会看到你不喜欢的东西，要么是因为它的优点不明显，要么是因为它冒犯了您的敏感性。尽管如此，这样的代码还是很有价值的，因为它有助于让您对好的代码和坏的代码建立自身的认识。 在学习 R 时，科学思维非常有帮助。如果您不了解某些东西是如何工作的，您应该提出一个假设，设计一些实验，运行它们并记录结果。这种方式非常有用，因为如果您自身无法解决问题并需要帮助，您可以轻松地向他人展示您的实验。同样，当您获取到了正确知识时，您也将更加认同这样的思维学习方式。 1.6 推荐阅读 由于 R 社区主要由数据科学家而非计算机科学家组成，因此深入研究 R 技术基础的书籍相对较少。在我个人理解 R 的过程中，我发现使用其他编程中的资源十分有意义。 R 具有函数式编程和面向对象 (OO)编程两种特性，了解这些特性在 R中如何实现将帮助您充分利用现有在其他语言中建立的知识体系，并将帮助您确认可以改进的方向。 如果您想要了解R的对象系统是如何工作的，《计算机程序的构造和解释》（SICP）(Abelson, Sussman, and Sussman 1996) 这本书非常有帮助。这是一本简介而深刻的书，读完这本书，我第一次感觉自己可以设计一个面向对象系统了。这本书是R语言面向对象编程范式的灵感起源，它帮助我了解了这种范式的优缺点。SICP还可以教会大家函数式编程范式，您可以创建相对独立的“纯”函数，并将它们组合起来实现更强大的功能。 为了了解R语言与其它编程语言之间的优劣，《计算机编程的概念，技术与模型》(Van-Roy and Haridi 2004)这本书非常有用，它让我了解了R语言copy-on-modify的含义，这使得代码理解更加容易，虽然它的实现方式并不是十分有效，但这是一个可以解决的问题。 如果您想成为一名更好的程序员，没有比阅读《程序员修炼之道》(Hunt and Thomas 1990)更好的选择了。这本书与编程语言无关，它为如何成为一句更好的程序员提供了很好的建议。 1.7 获取帮助 当您遇到无法解决的问题时，有三个主要的途径可以获取帮助：RStudio社区、StackOverflow 和 R-help邮件列表。您可以在每个地方获取到帮助，但这些地方也各有特色。在发布第一个贴子之前，花一点时间了解社区的风格是一个比较好的做法。 再给大家一些通用的建议： 请确保您安装了最新版本的R语言及工具包，或许您遇到的问题已经在最新版本中作为bug被修复。 花一些时间创建一个可重现的实验或者reprex，这将帮助他人也帮助您自己，而且有时候可以在不询问他人的情况下找到答案，因为在使问题重现的过程中，您通常会找出问题所在。我强烈推荐学习和使用reprex包。 如果您需要针对本书习题的帮助，可以从 Malte Grosser 和 Henning Bumann 获得解决方案，网址为 https://advanced-r-solutions.rbind.io 1.8 致谢 我要感谢 R-devel 和 R-help 的许多贡献者以及Stack Overflow 和 RStudio 社区。 有太多朋友对本书进行了贡献，原谅我无法一一列举，但我要特别感谢 Luke Tierney、John Chambers、JJ Allaire 和 Brian Ripley，他们慷慨地付出了宝贵的时间，纠正了我许多的错误。 这本书是公开编写的，完成后会在推特上发布章节。 这确实是一项社区努力：许多人阅读草稿、进行勘误、提出改进建议并贡献内容。 如果没有这些贡献者，这本书就不会这么好，我非常感谢他们的帮助。 特别感谢 Jeff Hammerbacher、Peter Li、Duncan Murdoch 和 Greg Wilson，他们从头到尾阅读了本书并提供了许多修正和建议。 1.9 约定 全书我使用f()代表函数，g代表变量和函数参数，h/代表路径 较大的代码块包含了输入和输出。 输出带有注释 (#&gt;)，因此如果您有本书的电子版本，例如 https://adv-r.hadley.nz/，您可以轻松地将示例复制并粘贴到 R 中运行。 本书许多示例使用了随机数，我们需要设定set.seed(1014)使结果重现，它在每章开始时自动执行。 1.10 使用的R包 package version source bench 1.1.1 CRAN (R 4.0.2) bookdown 0.24 CRAN (R 4.0.2) bslib 0.3.1 CRAN (R 4.0.2) dbplyr 2.1.1 CRAN (R 4.0.2) desc 1.4.0 CRAN (R 4.0.2) downlit 0.2.1 CRAN (R 4.0.2) dplyr 1.0.7 CRAN (R 4.0.2) ggbeeswarm 0.6.0 CRAN (R 4.0.2) ggplot2 3.3.5 CRAN (R 4.0.2) jsonlite 1.7.2 CRAN (R 4.0.2) knitr 1.36 CRAN (R 4.0.2) lobstr 1.1.1 CRAN (R 4.0.2) memoise 2.0.0 CRAN (R 4.0.2) png 0.1-7 CRAN (R 4.0.2) profvis 0.3.7 CRAN (R 4.0.2) Rcpp 1.0.7 CRAN (R 4.0.2) rlang 0.4.12 CRAN (R 4.0.2) rmarkdown 2.11 CRAN (R 4.0.2) RSQLite 2.2.8 CRAN (R 4.0.2) scales 1.1.1 CRAN (R 4.0.2) sessioninfo 1.1.1 CRAN (R 4.0.2) sloop 1.0.1 CRAN (R 4.0.2) testthat 3.1.0 CRAN (R 4.0.2) tibble 3.1.5 CRAN (R 4.0.2) tidyr 1.1.4 CRAN (R 4.0.2) vctrs 0.3.8 CRAN (R 4.0.2) xml2 1.3.2 CRAN (R 4.0.2) zeallot 0.1.0 CRAN (R 4.0.2) 参考文献 "],["foundation-intro.html", "基础知识概述", " 基础知识概述 接下来您将开启R语言学习之旅，以下七章将帮助您学习 R 的基础组件。我希望您以前已经看过其中的许多内容，但您可能没有深入研究它们。 为了检查您现有的知识体系，每章都以测验开始；如果您答对了所有问题，请随时跳到下一章！ 第 2 章会教您一个可能没有深入思考过的重要知识点：对象与对象名之间的区别。这里将改进您对 R 语言复制数据时的认识，从而更好地预测哪些操作是廉价的，哪些是昂贵的。 第 3 章深入探讨向量的细节，帮助您了解不同类型的向量如何组合在一起。 您还将了解属性，它允许您存储任意元数据，并构成 R 的两个面向对象编程工具包的基础。 第 4 章介绍了如何使用子集编写清晰、简洁和高效的 R 代码。 了解基本组件将使您能够通过组合各类组件来解决新问题。 第 5 章介绍了控制流工具，它们允许您仅在特定条件下执行代码，或者在更改输入的情况下重复执行代码。 其中包括重要的 if 和 for 结构，以及switch() 和 while。 第 6 章介绍函数，这是 R 语言最重要的组件。 您将深入地了解它们的工作原理，包括作用域规则，这些规则控制 R 如何通过变量名查找变量值。 您还将了解惰性求值背后的更多细节，以及如何控制退出函数时可以执行的动作。 第 7 章描述了一种对于理解 R 的工作方式至关重要但对数据分析来说并不重要的数据结构：环境。 环境是将名称绑定到值的数据结构，它为包的命名空间等工具提供支持。与大多数编程语言不同，R 中的环境是“一等类型”，这意味着您可以像操作其他对象一样操作它们。 第 8 章通过对“条件”（用于描述错误、警告和消息的总称）的探索来总结 R 的基础知识。 您以前肯定遇到过这些，因此在本章中，您将学习如何在自己编写的函数中使用条件，以及在其他地方出现这些信息时如何处理它们。 "],["name-and-value.html", "第 2 章 对象名与对象值 2.1 概述 2.2 数据绑定基础 2.3 修改时复制（Copy-on-modify） 2.4 对象大小 2.5 原地修改（Modify-on-place） 2.6 对象解绑与垃圾收集 2.7 测试题答案", " 第 2 章 对象名与对象值 2.1 概述 在R中，了解对象与其名称之间的区别非常重要，这样可以帮助您： 更准确地预测代码的性能和内存使用情况。 通过避免意外复制来编写更快的代码，这是慢代码的主要来源。 更好地理解 R 的函数式编程工具。 本章的目标是帮助您理解对象名称和值之间的区别，以及 R 何时复制对象。 测验 回答以下问题，看看您是否可以通过本章。您可以在本章末尾的第 2.7 节中找到答案。 给定以下数据框，如何创建一个名为“3”的新列，其中包含 1 和 2 的总和？ 您只能使用 $，而不能使用 [[。 是什么让 1、2 和 3 无法直接作为变量名？ df &lt;- data.frame(runif(3), runif(3)) names(df) &lt;- c(1, 2) 在下列代码中，y占据了多少内存？ x &lt;- runif(1e6) y &lt;- list(x, x, x) 在下面的例子中，变量a在哪一行被复制？ a &lt;- c(1, 5, 3, 2) b &lt;- a b[[1]] &lt;- 10 题纲 第 2.2 节向您介绍了名称和值之间的区别，并讨论了 &lt;- 如何在名称和值之间创建绑定或引用。 第 2.3 节描述了 R 何时进行复制：每当您修改向量时，几乎肯定会创建一个新的、修改过的向量。您将学习如何使用 tracemem() 来确定复制实际发生的时间。然后，您将探索这一能力在函数调用、列表、数据框和字符向量中的具体实现。 第 2.4 节探讨了前两节所涉及的对象占用内存量的一些深入问题。 由于您的直觉可能非常错误，并且 utils::object.size()这个方法计算出的结果也不准确，所以您将学习如何使用 lobstr::obj_size()得到正确的结果。 第 2.5 节描述了修改时复制的两个重要例外：对于具有单一名称的环境和值，对象实际上是在原地修改的。 第 2.6 节以讨论垃圾收集器结束本章，它释放不再被名称引用的对象所使用的内存。 先决条件 我们将使用lobstr包深入研究R对象的内部实现。 library(lobstr) 资源 R内存管理的细节知识并没有记录在某一篇文档里。本章中的大部分信息都是通过仔细阅读各类文档（特别是通过?Memory和?gc来查看）、编写 R扩展 (R Core Team 2018b)的内存分析部分和编写 R internals(R Core Team 2018a) 的SEXPs部分收集而来的。其余的知识我是通过阅读C源代码、进行小实验以及在R-devel上提问来掌握的。文中的任何错误都是由我造成的。 2.2 数据绑定基础 考虑下列代码： x &lt;- c(1, 2, 3) 这句代码很容易被理解为：创建了一个名为’x’的对象，其中包含1，2，3三个值。很不幸，这种简化的表述会造成我们对R在背后所做的事情理解不深，更确切的说，这段代码做了两件事情： 创建了一个值向量的对象，c(1, 2, 3) 将这个对象绑定在一个对象名x上 换句话说，创建一个对象或者对象的值，本身是没有名称的；而对象名称往往都绑定了一个值在上面。 为了进一步讲述这两者之间的区别，我绘制了如下图表： x代表对象名，被一个圆角矩形包裹，它有一个箭头指向（绑定或引用）对象值，即向量c(1, 2, 3)。箭头的方向与赋值号相反：&lt;-创建了一个右侧的对象值与左侧的对象名之间的绑定 因此，可以将名称视为对值的引用。例如，如果运行下列代码，将不会获得对象c(1, 2, 3)的另一个副本，而是获得现有对象的另一个绑定。 y &lt;- x 您可能已经注意到，c(1, 2, 3)有一个标签0x74b，虽然向量没有名称，但我偶尔也需要不依赖名称而直接使用对象。为了实现这一点，通常我使用唯一标识符标记对象值。这些标识符有一种特殊的形式，看起来像对象的内存“地址”，即对象在内存中存储的位置。但是因为每次运行代码时实际的内存地址都会发生变化，所以我们使用这些标识符来代替。 可以使用lobstr::obj_addr()访问对象标识符，这样您可以看到x和y都指向相同的标识符。 obj_addr(x) #&gt; [1] &quot;0x43663e8&quot; obj_addr(y) #&gt; [1] &quot;0x43663e8&quot; 这些标识符很长，每次重启R的时候都会发生变化。 了解对象名称和值之间的区别可能需要一些时间，但是理解这一点对于函数式编程非常有用，因为函数在不同的上下文中可以有不同的名称。 2.2.1 命名规则 R对于对象的命名规则有着严格的规定，合法的名称 必须由字母1、数字、.和_构成，但不能以_和数字开头。此外，您不能使用任何保留字，如TRUE，NULL，if，function（通过?Reserved查看详细列表）。不遵循这些命名规则的名称是非法名称，如果您尝试使用它们，系统将报错。 _abc &lt;- 1 #&gt; Error: unexpected input in &quot;_&quot; if &lt;- 10 #&gt; Error: unexpected assignment in &quot;if &lt;-&quot; 通过为对象名增加反引号，可以破除上述命名规则，使用任何对象名。 `_abc` &lt;- 1 `_abc` #&gt; [1] 1 `if` &lt;- 10 `if` #&gt; [1] 10 虽然您不太可能故意创建这些疯狂的名称，但您需要了解这些疯狂的名称是如何工作的，因为您会遇到它们，最常见的情况是在加载在R之外创建的数据时。 您也可以使用单引号或双引号（例如“_abc” &lt;- 1）而不是反引号来创建非语法的对象名，但您不应该这样做，因为您可能会使用不同的语法来获取对象值，况且赋值箭头的左侧使用字符串的能力是一个在反引号出现之前的历史产物。 2.2.2 习题 请解释下列代码中a, b, c, d之间的关系。 a &lt;- 1:10 b &lt;- a c &lt;- b d &lt;- 1:10 下面的代码以多种方式访问mean函数。它们是否都指向相同的底层函数对象？用lobstr::obj_addr()验证这一点。 mean base::mean get(&quot;mean&quot;) evalq(mean) match.fun(&quot;mean&quot;) 默认情况下，base R中的数据导入函数（如read.csv()）将自动将非法名称转换为合法名称。为什么这可能会带来问题？什么选项允许您抑制这种行为？ make.names()使用什么规则将非法名称转换为合法名称？ 我稍微简化了命名规则。为什么.123e1不是一个合法名称？详细信息请阅读?make.names。 2.3 修改时复制（Copy-on-modify） 考虑下面的代码，它将x和y绑定到相同的基础对象值，然后再修改y2。 x &lt;- c(1, 2, 3) y &lt;- x y[[3]] &lt;- 4 x #&gt; [1] 1 2 3 修改y显然没有修改x，但x与y绑定了同一个对象，那么修改到底发生了什么？虽然与y关联的值发生了变化，但原始对象没有发生变化，相反，R创建了一个新对象0xcd2，它是0x74b对象的副本，将它的值发生改变后重新绑定至y。 这种行为被称作修改时复制，理解它会从根本上提高您对R代码的感觉，通常我们会把这种行为描述为R对象是不可变的，但是我通常会避免使用该术语，因为修改时复制的特性有几个非常重要的例外，我将在第2.5节中介绍。 当以交互方式探索“修改时复制”的行为时，请注意您将在 RStudio 中获得不同的结果，那是因为环境面板必须引用每个对象才能显示有关它的信息。这会让您对交互式探索产生误判，但不会影响函数内部的代码，因此不会影响数据分析期间的性能。对于实验，我建议直接从终端运行 R，或者使用 RMarkdown（就像本书一样）。 2.3.1 tracemem() 您可以使用base::tracemem()函数查看对象何时被复制，一旦您用一个对象调用这个函数，您会得到这个对象的当前地址： x &lt;- c(1, 2, 3) cat(tracemem(x), &quot;\\n&quot;) #&gt; &lt;0x7f80c0e0ffc8&gt; 从这时起，无论何时复制该对象，tracemem() 都会打印一条消息，告诉您复制了哪个对象、它的新地址以及修改时复制的调用序列： y &lt;- x y[[3]] &lt;- 4L #&gt; tracemem[0x7f80c0e0ffc8 -&gt; 0x7f80c4427f40]: 如果您再次修改y，它将不会被复制。这是因为新对象现在只有一个绑定到它的对象名，所以R使用了原地修改进行优化，我们将在2.5节中详细讨论。 y[[3]] &lt;- 5L untracemem(x) untracemem()与tracemem()相反，它关闭对对象的追踪。 2.3.2 函数调用 修改时复制的相关规则也适用于函数调用，以下列代码为例： f &lt;- function(a) { a } x &lt;- c(1, 2, 3) cat(tracemem(x), &quot;\\n&quot;) #&gt; &lt;0x72ab6b8&gt; z &lt;- f(x) # there&#39;s no copy here! untracemem(x) 当f()运行时，函数内部的变量名a与函数外部变量名x指向相同的值： 您将在7.4.4节了解更多关于上图的相关知识。简而言之，函数f()由右侧的黄色对象表示，它有一个形参a，当函数运行时，它成为执行环境（灰色矩形框）中的绑定（由黑色虚线表示）。 一旦f()运行完毕，x和z将指向同一个对象，由于0x74b没有被修改，所以它不会被复制，如果f()确实修改了x，那么R将创建一个新副本，然后z将绑定该对象。 2.3.3 列表 变量名不只能指向向量值，也能指向列表，它与上面的向量非常相似： l1 &lt;- list(1, 2, 3) 列表更为复杂，因为它不是存储值的本身，而是存储它们的引用。 这对于修改列表时非常重要： l2 &lt;- l1 l2[[3]] &lt;- 4 与向量类似，列表也有修改时复制的特性；原始列表保持不变，R创建一个修改后的副本。然而，这是一个浅拷贝：即列表对象及其绑定被复制，但绑定的值没有被复制。与浅拷贝相反的是深拷贝，即每个引用的内容都被复制。在R 3.1.0版本之前，所有的拷贝都是深拷贝。 要查看跨列表的共享值，请使用lobstr::ref()函数。ref()打印每个对象的内存地址及本地ID，以便您可以轻松发现跨列表的引用值。 ref(l1, l2) #&gt; █ [1:0x4217278] &lt;list&gt; #&gt; ├─[2:0x49ee9f0] &lt;dbl&gt; #&gt; ├─[3:0x49ee9b8] &lt;dbl&gt; #&gt; └─[4:0x49ee980] &lt;dbl&gt; #&gt; #&gt; █ [5:0x72c2548] &lt;list&gt; #&gt; ├─[2:0x49ee9f0] #&gt; ├─[3:0x49ee9b8] #&gt; └─[6:0x75e20e0] &lt;dbl&gt; 2.3.4 数据框 数据框是向量列表，因此在修改数据框时，修改时复制的特性会产生重要影响。以这个数据框为例： d1 &lt;- data.frame(x = c(1, 5, 6), y = c(2, 4, 3)) 如果修改了一列，只有那一列发生了修改时复制，其他列仍将指向其原始的引用： d2 &lt;- d1 d2[, 2] &lt;- d2[, 2] * 2 如果修改了一行，每列值都被修改，这就意味着每列值被发生了修改时复制： d3 &lt;- d1 d3[1, ] &lt;- d3[1, ] * 3 2.3.5 字符向量 R语言最后一个使用引用的地方是字符向量3，我通常用如下的方式表达字符向量： x &lt;- c(&quot;a&quot;, &quot;a&quot;, &quot;abc&quot;, &quot;d&quot;) 但这只是示意，事实上R使用一个全局字符串池，字符向量中的每个元素都是指向池中唯一字符串的指针: 您可通过调用character参数设置为TRUE的ref()函数来显示这些引用。 ref(x, character = TRUE) #&gt; █ [1:0x71c0af8] &lt;chr&gt; #&gt; ├─[2:0x10b3e20] &lt;string: &quot;a&quot;&gt; #&gt; ├─[2:0x10b3e20] #&gt; ├─[3:0x8558770] &lt;string: &quot;abc&quot;&gt; #&gt; └─[4:0x1274688] &lt;string: &quot;d&quot;&gt; 这种设计对于字符向量使用的内存量有很大的影响，但在其它方面无关紧要，因此在本书的后续章节，我在画图的时候依然会把字符串画在向量内部。 2.3.6 习题 为什么运行tracemem(1:10)没有意义？ 解释一下为何下列代码运行tracemem(x)后出现两条拷贝信息？提示：认真查看这个代码与前面章节中的代码不同之处。 x &lt;- c(1L, 2L, 3L) tracemem(x) x[3] &lt;- 4 绘制以下对象之间的关系图。 a &lt;- 1:10 b &lt;- list(a, a) c &lt;- list(b, a, 1:10) 当运行下列代码时，会发生什么？ x &lt;- list(1:10) x[[2]] &lt;- x 2.4 对象大小 您可以通过lobstr::obj_size()4函数查看一个对象占用了多少内存。 obj_size(letters) #&gt; 1,712 B obj_size(ggplot2::diamonds) #&gt; 3,456,344 B 由于列表的元素是对值的引用，因此列表的大小可能比您预期小的多： x &lt;- runif(1e6) obj_size(x) #&gt; 8,000,048 B y &lt;- list(x, x, x) obj_size(y) #&gt; 8,000,128 B y只比x大80个字节5，这是一个包含三个元素的空列表的大小： obj_size(list(NULL, NULL, NULL)) #&gt; 80 B 类似的,因为R使用全局字符串池，所以字符向量占用的内存比您预期的少：重复字符串100次并不会使它占用100倍的内存。 banana &lt;- &quot;bananas bananas bananas&quot; obj_size(banana) #&gt; 136 B obj_size(rep(banana, 100)) #&gt; 928 B 引用的存在使得估计单个对象的大小变得比较困难，如果没有共享值，obj_size(x) + obj_size(y)将等于obj_size(x, y)，如下列代码所示，x与y组合的大小等于y单独的大小。 obj_size(x, y) #&gt; 8,000,128 B 最后，R 3.5.0之后的版本提供了一个令人兴奋的能力：ALTREP，即替代形式(alternative representation)。这种特性允许R采用:这种非常紧凑的方式表示向量，这种方式用存储向量的起始值与结束值代替存储每个值，这意味着不论您的向量有多少个值，它都拥有相同的大小。 obj_size(1:3) #&gt; 680 B obj_size(1:1e3) #&gt; 680 B obj_size(1:1e6) #&gt; 680 B obj_size(1:1e9) #&gt; 680 B 2.4.1 习题 在下面的例子中，为何object.size()与object_size()的结果有巨大的差异？请阅读object_size()的文档寻找答案。 y &lt;- rep(list(runif(1e4)), 100) object.size(y) #&gt; 8005648 bytes object.size(y) #&gt; 8005648 bytes 以下面的列表为例，为什么它的大小与想的不一样？ funs &lt;- list(mean, sd, var) obj_size(funs) #&gt; 17,608 B 预测以下代码的输出结果。 a &lt;- runif(1e6) obj_size(a) b &lt;- list(a, a) obj_size(b) obj_size(a, b) b[[1]][[1]] &lt;- 10 obj_size(b) obj_size(a, b) b[[2]][[1]] &lt;- 10 obj_size(b) obj_size(a, b) 2.5 原地修改（Modify-on-place） 正如我们在上面看到的那样，修改R对象通常会创建一个副本，但这里有两个例外： 单一绑定对象可获得特殊的性能优化。 环境是一种特殊类型的对象，它总是在原地修改。 2.5.1 单一绑定对象 如果对象只被一个对象名绑定，R将原地修改这个变量： v &lt;- c(1, 2, 3) v[[3]] &lt;- 4 （请注意对象ID：v始终绑定在同一对象上，0x207。） 有两个复杂因素使得预测R何时开展性能优化变得有难度： 说到绑定，R目前只能按0，1或多个来计数。这就意味着，假如一个对象拥有2个绑定，当一个消失时，引用计数不会回到1：多个减去1还等于多个。反过来就说明R有时会在不需要的时候进行复制。 当您调用绝大多数函数的时候，它都会为对象创建引用，唯一的例外是专门编写的“原始”C函数。这些只能由R的核心开发团队编写，并且主要出现在base包中。 总之，这两种复杂的情况使得预测是否会产生副本变得很难，因此用tracemem()函数来判断是很好的经验。 让我们通过使用for循环的案例研究来探索其中的微妙之处，for循环在R中是比较慢的，这种慢通常是由于循环的每次迭代都会创建一直副本造成的。考虑下面的代码，经从一个大型数据框的每一列减去一个值： x &lt;- data.frame(matrix(runif(5 * 1e4), ncol = 5)) medians &lt;- vapply(x, median, numeric(1)) for (i in seq_along(medians)) { x[[i]] &lt;- x[[i]] - medians[[i]] } 这个循环运行的非常慢，因为每次迭代都会复制数据框，您可以使用tracemem()函数来监控运行： cat(tracemem(x), &quot;\\n&quot;) #&gt; &lt;0x7f80c429e020&gt; for (i in 1:5) { x[[i]] &lt;- x[[i]] - medians[[i]] } #&gt; tracemem[0x7f80c429e020 -&gt; 0x7f80c0c144d8]: #&gt; tracemem[0x7f80c0c144d8 -&gt; 0x7f80c0c14540]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14540 -&gt; 0x7f80c0c145a8]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c145a8 -&gt; 0x7f80c0c14610]: #&gt; tracemem[0x7f80c0c14610 -&gt; 0x7f80c0c14678]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14678 -&gt; 0x7f80c0c146e0]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c146e0 -&gt; 0x7f80c0c14748]: #&gt; tracemem[0x7f80c0c14748 -&gt; 0x7f80c0c147b0]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c147b0 -&gt; 0x7f80c0c14818]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14818 -&gt; 0x7f80c0c14880]: #&gt; tracemem[0x7f80c0c14880 -&gt; 0x7f80c0c148e8]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c148e8 -&gt; 0x7f80c0c14950]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14950 -&gt; 0x7f80c0c149b8]: #&gt; tracemem[0x7f80c0c149b8 -&gt; 0x7f80c0c14a20]: [[&lt;-.data.frame [[&lt;- #&gt; tracemem[0x7f80c0c14a20 -&gt; 0x7f80c0c14a88]: [[&lt;-.data.frame [[&lt;- untracemem(x) 事实上，每次迭代不止复制的一次数据框，也不止是两次，而是三次。[[.data.frame先生成了两个副本，然后又生成了一个6，因为[[.data.frame是一个常规函数，它会增加x的引用计数。 我们可以通过使用列表而不是数据框来减少副本复制的数量，修改列表使用的是内部C函数，因此不会增加引用计数，只生成一个副本： y &lt;- as.list(x) cat(tracemem(y), &quot;\\n&quot;) #&gt; &lt;0x7f80c5c3de20&gt; for (i in 1:5) { y[[i]] &lt;- y[[i]] - medians[[i]] } #&gt; tracemem[0x7f80c5c3de20 -&gt; 0x7f80c48de210]: 虽然不难发现何时产生了副本，但却很难阻止它。如果您发现自己在使用一些奇异的技巧避免产生复制，那可能是时候用C++重写您的函数了，这些内容我们将在第25章中讲述。 2.5.2 环境 您将在第7章学习更多与环境相关的知识，但在这里提及它们十分重要，因为它们的行为与其它对象的行为不同：环境总是在适当的地方进行修改。这种属性有时被成为引用语义，因为当您修改环境时，所有这个环境中的所有绑定将继续保持相同的引用。 如同下列这个绑定到e1和e2的环境： e1 &lt;- rlang::env(a = 1, b = 2, c = 3) e2 &lt;- e1 如果我们改变了绑定，环境也就地修改。 e1$c &lt;- 4 e2$c #&gt; [1] 4 这个特性可以用于创建“可记住”先前状态的函数，更多的信息请见10.2.1。这个特性实现了R6面向对象系统，这将在第14章详细介绍。 这样做的一个重要结果是环境可以包含自己： e &lt;- rlang::env() e$self &lt;- e ref(e) #&gt; █ [1:0x5916dd8] &lt;env&gt; #&gt; └─self = [1:0x5916dd8] 这是环境对象唯一的属性。 2.5.3 习题 解释一下为何下列代码没有创建一个循环列表 x &lt;- list() x[[1]] &lt;- x 将上述两个减中位数的方法包装成两个函数，调用bench包比较两个方法的速度。随着列数增加，性能如何变化？ 如果您尝试在环境中使用tracemem()函数会发生什么？ 2.6 对象解绑与垃圾收集 考虑下列代码： x &lt;- 1:3 x &lt;- 2:4 rm(x) 我们创建了两个对象，但等到代码运行完毕后，没有一个对象绑定到了对象名。这些对象如何被删除？这个工作交给了垃圾收集器，简称GC。GC释放那些已经被删除的对象所占用的内存，并在需要时从操作系统请求更多内存。 R使用追踪式垃圾收集器，这意味着它会跟踪可以从全局环境7访问的每个对象，以及可从这些对象上访问的所有对象（即可递归搜索的列表与环境中的引用）。垃圾收集器不使用上述原地修改引用计数，虽然垃圾收集器与引用计数是密切相关的，但内部数据结构针对不同用例进行了优化。 每个R需要更多内存来创建新对象时，垃圾收集器(GC)就会自动运行，从外部来看，基本上没法预测GC何时运行。事实上，你也不应该尝试预测。如果您想知道GC何时运行，请调用gcinfo(TRUE)，GC将在每次运行时向控制台打印一条消息。 可以通过调用gc()函数来强制垃圾收集，这一点您可以已经在其它地方有所了解，但您永远不需要这么做。调用gc()的唯一原因可能是要求R将内存返回到操作系统，以便其他程序可以使用它，或者是告诉您当前使用了多少内存，这其实是一个额外的作用： gc() #&gt; used (Mb) gc trigger (Mb) max used (Mb) #&gt; Ncells 855070 45.7 1645301 87.9 1645301 87.9 #&gt; Vcells 4962720 37.9 17010142 129.8 17009272 129.8 lobstr::mem_used()函数是gc()的包装器，用于打印使用字节的总数： mem_used() #&gt; 87,591,776 B 这个数字与您操作系统显示的可能不一样，主要是由下列三个原因造成的： 它包括由R创建的对象，但不包括由R解释器创建的对象。 R和操作系统都是惰性的：它们都是到了真正需要的时候才会回收内存。因此R可能会占用内存，因为操作系统还未要求它返回。 R统计对象占用的内存，但可能会因为删除的对象而存在空白。这个问题称为内存碎片化。 2.7 测试题答案 你必须使用反引号`引用非法名称：例如，例如变量1, 2, 3。 df &lt;- data.frame(runif(3), runif(3)) names(df) &lt;- c(1, 2) df$`3` &lt;- df$`1` + df$`2` 它大约占用8Mb。 x &lt;- runif(1e6) y &lt;- list(x, x, x) obj_size(y) #&gt; 8,000,128 B 当b发生修改时，a会复制。即在b[[1]] &lt;- 10这一行发生复制。 参考文献 "],["vectors.html", "第 3 章 向量 3.1 概述 3.2 原子向量 3.3 属性 3.4 S3原子向量 3.5 列表 3.6 数据框和tibble 3.7 NULL 3.8 测试题答案", " 第 3 章 向量 3.1 概述 本章讨论R基础包中最重要的数据结构：向量8。虽然您可能已经使用了许多（如果不是全部）不同类型的向量，但您可能没有深入思考它们之间的相互关系。在本章中，我不会过多地介绍各个向量类型，但我会向您展示所有类型如何组合在一起。如果您需要更多详细信息，可以在R的文档中找到它们。 向量有两种形式：原子向量和列表9。它们的元素类型不同：对于原子向量，所有元素必须具有相同的类型； 对于列表，元素可以有不同的类型。虽然不是向量，但NULL与向量密切相关，并且通常充当通用零长度向量的角色。我们将在本章中不断扩展这张图来说明向量间的基本关系： 每个向量还可以具有属性，可以将其视为任意元数据的命名列表，有两个属性非常的重要。维度属性将向量转化为矩阵和数组，类别属性为S3对象系统提供了强大的能力。虽然您将在第13章中学习如何使用 S3，但在这里您将了解一些最重要的S3向量：因子、日期、时间、数据框和tibble。当您想到向量时，虽然不一定会想到矩阵和数据框等二维数据结构，但您还将了解为什么 R 将它们视为向量。 测试 参加这个简短的测验，以确定您是否需要阅读本章。如果很快就能想到答案，您可以轻松跳过本章。 您可以在第3.8节中检查您的答案。 四种常见的原子向量类型是什么？两种罕见的类型是什么? 什么是属性？你如何获取和设置它们？ 列表与原子向量有何不同？矩阵与数据框有何不同？ 你能有一个矩阵列表吗？数据框可以有一个矩阵列吗？ tibble与数据框的行为有何不同？ 题纲 第3.2节向您介绍了原子向量：逻辑型向量、整型向量、双精度型向量和字符型向量。 这些是 R 最简单的数据结构。 第3.3节绕道讨论属性，R 的灵活元数据规范。 最重要的属性是名称、维度和类别。 第3.4节讨论了通过将具有特殊属性的原子向量组合而构建的重要向量类型。 这些包括因子、日期、日期时间和持续时间 第3.5节深入研究列表。列表与原子向量非常相似，但有一个关键区别：列表的元素可以是任何数据类型，包括另一个列表。这使得它们适用于表示分层数据。 第3.6节将教您用于表示矩形数据的数据框和tibble。它们结合了列表和矩阵的行为，非常适合统计数据的需要。 3.2 原子向量 3.3 属性 3.4 S3原子向量 3.5 列表 3.6 数据框和tibble 3.7 NULL 3.8 测试题答案 总的来说，所有其他数据类型都称为“节点”类型，其中包括函数和环境等。在使用 gc() 时，您最有可能遇到这个技术性很强的术语：Ncells 中的“N”代表节点，而Vcells中的“V”代表向量。↩︎ R文档的一些地方把列表称为通用向量，以强调它们与原子向量的区别。↩︎ "],["subsetting.html", "第 4 章 子集 4.1 简介 4.2 选择多个元素 4.3 选择单个元素", " 第 4 章 子集 4.1 简介 4.2 选择多个元素 4.3 选择单个元素 "],["control-flow.html", "第 5 章 控制流 5.1 张老爷子 5.2 彭大将领", " 第 5 章 控制流 瞎扯几句。 5.1 张老爷子 话说张老爷子写了一首诗： 姑苏开遍碧桃时，邂逅河阳女画师。 红豆江南留梦影，白苹风末唱秋词。 5.2 彭大将领 貌似大家都喜欢用白萍风这个意境。又如彭玉麟的对联： 凭栏看云影波光，最好是红蓼花疏、白苹秋老； 把酒对琼楼玉宇，莫孤负天心月到、水面风来。 嘿，玛尼玛尼哄。 "],["functions.html", "第 6 章 函数 6.1 简介 6.2 函数组合 6.3 函数类型", " 第 6 章 函数 6.1 简介 话说张老爷子写了一首诗： 姑苏开遍碧桃时，邂逅河阳女画师。 红豆江南留梦影，白苹风末唱秋词。 6.2 函数组合 貌似大家都喜欢用白萍风这个意境。又如彭玉麟的对联： 凭栏看云影波光，最好是红蓼花疏、白苹秋老； 把酒对琼楼玉宇，莫孤负天心月到、水面风来。 6.3 函数类型 "],["environments.html", "第 7 章 环境 7.1 简介 7.2 基础环境 7.3 在环境上递归 7.4 特殊环境 7.5 堆栈调用 7.6 作为数据结构", " 第 7 章 环境 瞎扯几句。 7.1 简介 话说张老爷子写了一首诗： 姑苏开遍碧桃时，邂逅河阳女画师。 红豆江南留梦影，白苹风末唱秋词。 7.2 基础环境 7.3 在环境上递归 7.4 特殊环境 7.4.1 包环境与搜索路径 7.4.2 函数环境 7.4.3 命名空间 7.4.4 执行环境 7.5 堆栈调用 7.6 作为数据结构 "],["conditions.html", "第 8 章 条件 8.1 自定义条件", " 第 8 章 条件 8.1 自定义条件 "],["fp-intro.html", "函数式编程概述", " 函数式编程概述 "],["functionals.html", "第 9 章 泛型函数 9.1 张老爷子 9.2 彭大将领", " 第 9 章 泛型函数 瞎扯几句。 9.1 张老爷子 话说张老爷子写了一首诗： 姑苏开遍碧桃时，邂逅河阳女画师。 红豆江南留梦影，白苹风末唱秋词。 9.2 彭大将领 貌似大家都喜欢用白萍风这个意境。又如彭玉麟的对联： 凭栏看云影波光，最好是红蓼花疏、白苹秋老； 把酒对琼楼玉宇，莫孤负天心月到、水面风来。 嘿，玛尼玛尼哄。 "],["function-factories.html", "第 10 章 函数工厂 10.1 简介 10.2 函数工厂基础 10.3 图形工厂 10.4 统计工厂 10.5 函数工厂与泛函", " 第 10 章 函数工厂 10.1 简介 10.2 函数工厂基础 10.2.1 环境 10.2.2 图表约定 10.2.3 强制评估 10.2.4 有状态函数 10.2.5 垃圾收集 10.2.6 习题 10.3 图形工厂 10.4 统计工厂 10.5 函数工厂与泛函 "],["function-operators.html", "第 11 章 函数运算符 11.1 张老爷子 11.2 彭大将领", " 第 11 章 函数运算符 瞎扯几句。 11.1 张老爷子 话说张老爷子写了一首诗： 姑苏开遍碧桃时，邂逅河阳女画师。 红豆江南留梦影，白苹风末唱秋词。 11.2 彭大将领 貌似大家都喜欢用白萍风这个意境。又如彭玉麟的对联： 凭栏看云影波光，最好是红蓼花疏、白苹秋老； 把酒对琼楼玉宇，莫孤负天心月到、水面风来。 嘿，玛尼玛尼哄。 "],["oo-intro.html", "面向对象编程概述", " 面向对象编程概述 "],["base-types.html", "第 12 章 基础类型 12.1 张老爷子 12.2 彭大将领", " 第 12 章 基础类型 瞎扯几句。 12.1 张老爷子 话说张老爷子写了一首诗： 姑苏开遍碧桃时，邂逅河阳女画师。 红豆江南留梦影，白苹风末唱秋词。 12.2 彭大将领 貌似大家都喜欢用白萍风这个意境。又如彭玉麟的对联： 凭栏看云影波光，最好是红蓼花疏、白苹秋老； 把酒对琼楼玉宇，莫孤负天心月到、水面风来。 嘿，玛尼玛尼哄。 "],["s3.html", "第 13 章 S3对象系统", " 第 13 章 S3对象系统 "],["r6.html", "第 14 章 R6对象系统", " 第 14 章 R6对象系统 "],["s4.html", "第 15 章 S4对象系统", " 第 15 章 S4对象系统 "],["trade-offs.html", "第 16 章 对比分析 16.1 简介 16.2 彭大将领", " 第 16 章 对比分析 16.1 简介 话说张老爷子写了一首诗： 姑苏开遍碧桃时，邂逅河阳女画师。 红豆江南留梦影，白苹风末唱秋词。 16.2 彭大将领 貌似大家都喜欢用白萍风这个意境。又如彭玉麟的对联： 凭栏看云影波光，最好是红蓼花疏、白苹秋老； 把酒对琼楼玉宇，莫孤负天心月到、水面风来。 haha 嘿，玛尼玛尼哄。 "],["mp-intro.html", "元编程概述", " 元编程概述 "],["bigpicture.html", "第 17 章 全局", " 第 17 章 全局 "],["expressions.html", "第 18 章 表达式", " 第 18 章 表达式 "],["quasi.html", "第 19 章 准引用", " 第 19 章 准引用 "],["evaluation.html", "第 20 章 评估", " 第 20 章 评估 "],["translating.html", "第 21 章 R代码转换", " 第 21 章 R代码转换 "],["tech-intro.html", "编程技巧概述", " 编程技巧概述 "],["debugging.html", "第 22 章 代码调试", " 第 22 章 代码调试 "],["measuring.html", "第 23 章 性能度量", " 第 23 章 性能度量 "],["improving.html", "第 24 章 性能改进", " 第 24 章 性能改进 "],["rewriting.html", "第 25 章 在C++中重写R代码", " 第 25 章 在C++中重写R代码 "],["references.html", "参考文献", " 参考文献 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
