# 对象名与对象值 {#name-and-value}

## 概述

在R中，了解对象与其名称之间的区别非常重要，这样可以帮助您：

- 更准确地预测代码的性能和内存使用情况。
- 通过避免意外复制来编写更快的代码，这是慢代码的主要来源。
- 更好地理解 R 的函数式编程工具。

本章的目标是帮助您理解对象名称和值之间的区别，以及 R 何时复制对象。

### 测试题 {-}

回答以下问题，看看您是否可以通过本章。 您可以在本章末尾的第 \@ref(name-and-value-answers) 节中找到答案。

1. 给定以下数据框，如何创建一个名为“3”的新列，其中包含 `1` 和 `2` 的总和？ 您只能使用 `$`，而不能使用 `[[`。 是什么让 `1`、`2` 和 `3` 作为变量名具有挑战性？

```{r}
df <- data.frame(runif(3), runif(3))
names(df) <- c(1, 2)
```

2. 在下列代码中，`y`占据了多少内存？
```{r}
x <- runif(1e6)
y <- list(x, x, x)
```

3. 在下面的例子中，变量`a`在哪一行被复制？
```{r}
a <- c(1, 5, 3, 2)
b <- a
b[[1]] <- 10
```

### 题纲 {-}

- 第 \@ref(binding-basics) 节向您介绍了名称和值之间的区别，并讨论了 `<-` 如何在名称和值之间创建绑定或引用。
- 第 \@ref(copy-on-modify) 节描述了 R 何时进行复制：每当您修改向量时，几乎肯定会创建一个新的、修改过的向量。您将学习如何使用 `tracemem()` 来确定复制实际发生的时间。然后，您将探索这一能力在函数调用、列表、数据框和字符向量中的具体实现。
- 第 \@ref(object-size) 节探讨了前两节所涉及的对象占用内存量的一些深入问题。 由于您的直觉可能非常错误，并且 `utils::object.size()`这个方法计算出的结果也不准确，所以您将学习如何使用 `lobstr::obj_size()`得到正确的结果。
- 第 \@ref(modify-on-place) 节描述了修改时复制的两个重要例外：对于具有单一名称的环境和值，对象实际上是在原地修改的。
- 第 \@ref(gc) 节以讨论垃圾收集器结束本章，它释放不再被名称引用的对象所使用的内存。

### 先决条件 {-}

我们将使用`lobstr`包深入研究R对象的内部实现。
```{r}
library(lobstr)
```

### 资源 {-}

R内存管理的细节知识并没有记录在某一篇文档里。本章中的大部分信息都是通过仔细阅读各类文档（特别是通过`?Memory`和`?gc`来查看）、编写 _R扩展_ [@r-exts]的[内存分析](http://cran.r-project.org/doc/manuals/R-exts.html#Profiling-R-code-for-memory-use)部分和编写 _R internals_[@r-ints] 的[SEXPs](http://cran.r-project.org/doc/manuals/R-ints.html#SEXPs)部分收集而来的。其余的知识我是通过阅读C源代码、进行小实验以及在R-devel上提问来掌握的。文中的任何错误都是由我造成的。

## 数据绑定基础 {#binding-basics}


## 修改时复制（Copy-on-modify）{#copy-on-modify}

## 对象大小 {#object-size}

## 原地修改（Modify-on-place）{#modify-on-place}

## 数据解绑与垃圾收集 {#gc}

## 测试题答案 {#name-and-value-answers}
